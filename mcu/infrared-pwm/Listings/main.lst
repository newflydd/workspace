C51 COMPILER V9.56.0.0   MAIN                                                              07/20/2017 22:10:19 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\main
                    -.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /**
   2           * STC15F2K60Sç³»åˆ—ï¼Œçº¢å¤–å­¦ä¹ å’Œå‘é€é¥æ§å™¨
   3           * ä¸»é¢‘ï¼š19.456Mï¼ˆèƒ½ç²¾ç¡®å®ç°38KHzè°ƒåˆ¶æ³¢å½¢ï¼‰
   4           * 
   5           * çº¢å¤–å‘é€åŠŸèƒ½ï¼š
   6           * P02å‘é€sendCmd1è„‰å†²ä¿¡å·ï¼Œé€šè¿‡ä¸é—¨ï¼Œä¸PWMæ··åˆï¼Œå‘å¾€çº¢å¤–å‘å°„å™¨
   7           * P03æ¥å¾®åŠ¨å¼€å…³ï¼Œä¸‹æ‹‰è¾“å…¥ï¼Œå¹³æ—¶ä½ç”µå¹³ï¼Œæœ‰ä¿¡å·æ—¶é«˜ç”µå¹³
   8           *
   9           * çº¢å¤–è§£æåŠŸèƒ½ï¼š
  10           * INT0å’ŒINT1æ˜¯å¤–éƒ¨ä¸­æ–­
  11           * P3.2æ˜¯INT0ï¼ŒP3.3æ˜¯INT1
  12           * æœ¬ä¾‹é€šè¿‡INT0æ¥æ¥æ”¶HS0038çš„è§£è°ƒä¿¡å·
  13           * é€šè¿‡UARTå‘ä¸Šä½æœºå‘é€æ¥æ”¶çš„çº¢å¤–æ•°æ®
  14           */
  15          #include <STC15F2K.h>
  16          
  17          #define FOSC 19456000L
  18          #define CCP_S0  0x10  //P_SW1.4
  19          #define CCP_S1  0x20  //P_SW1.5
  20          
  21          void PWM0Init(void);        /* PWM0åˆå§‹åŒ–ï¼Œä¸»é¢‘19.456Mï¼Œåˆ†é¢‘ä¸º38KHz */
  22          void Uart1Init(void);       /* 9600bps@19.456MHz */
  23          void T0Init(void);          /* è®¡æ—¶å™¨0åˆå§‹åŒ– */
  24          void IT0Init();           /* å¤–éƒ¨ä¸­æ–­IT0åˆå§‹åŒ– */
  25          
  26          void sendInfraredByte(u8 dat);    /* æŒ‰å­—èŠ‚å‘é€çº¢å¤–æ•°æ® */
  27          void SendInfraredSignal(u8*);     /* å‘é€çº¢å¤–æŒ‡ä»¤ */
  28          
  29          void delay(u16 us);         /* å»¶æ—¶å‡½æ•° */
  30          
  31          /* çº¢å¤–å‘é€åŠŸèƒ½ */
  32          sbit  SendDataPin = P0^2; /* çº¢å¤–æ•°æ®å‘å°„å¼•è„šï¼Œä¸PWMé€šè¿‡74HC08æ··åˆå½¢æˆè°ƒåˆ¶ä¿¡å· */
  33          sbit  SendCmdPin  = P0^3; /* å®šä¹‰å‘å°„æŒ‰é’®å¾®åŠ¨å¼€å…³å¼•è„šï¼Œä¸Šæ‹‰ç”µé˜»ç»´æŒé«˜ç”µå¹³ï¼Œå¾®åŠ¨æŒ
             -‰ä¸‹æœ‰ä¸ªä¸‹é™æ²¿è§¦å‘ */
  34          u8 cmdOpen26[] = {0xC3, 0xE9, 0x00, 0x00, 0x04, 0x02, 0x04, 0x00, 0x00, 0x04, 0x00, 0xA0, 0xFF};
  35          u8 cmdClose26[]= {0xC3, 0xE9, 0x00, 0x00, 0x04, 0x02, 0x04, 0x00, 0x00, 0x00, 0x00, 0xA0, 0xFB};
  36          
  37          /* çº¢å¤–è§£è°ƒåŠŸèƒ½ */
  38          u8 idata buffer[128];       /* çº¢å¤–æ¥æ”¶æ•°æ®åŒºï¼Œæœ€å¤§é•¿åº¦128å­—èŠ‚ï¼Œå®Œå…¨æ»¡è¶³å„ç§çº¢å¤–é¥æ§
             -å™¨æŒ‡ä»¤é›† */
  39          u8 bufferLength = 0;        /* çº¢å¤–æ¥æ”¶æ•°æ®åŒºé•¿åº¦ */
  40          sbit IR_INPUT = P3^2;       /* ä½¿ç”¨å¤–éƒ¨ä¸­æ–­INT0æ¥æ”¶çº¢å¤–ä¿¡å· */
  41          
  42          u8  u8temp,i,j;
  43          u16 u16temp;
  44          volatile u8 sending;
  45          
  46          int main(){
  47   1        EA = 1;             /* æ€»ä¸­æ–­ä½¿èƒ½ */
  48   1      
  49   1        PWM0Init();           /* PWM0åˆå§‹åŒ–ï¼Œä¸»é¢‘19.456Mï¼Œåˆ†é¢‘ä¸º38KHz */
  50   1        Uart1Init();          /* ä¸²å£ä¼ è¾“ï¼ˆä¸²å£1ï¼‰åˆå§‹åŒ– */
  51   1        T0Init();           /* è®¡æ—¶å™¨0åˆå§‹åŒ– */
  52   1        IT0Init();            /* å¤–éƒ¨ä¸­æ–­IT0åˆå§‹åŒ– */
C51 COMPILER V9.56.0.0   MAIN                                                              07/20/2017 22:10:19 PAGE 2   

  53   1        
  54   1        IR_INPUT  = 1;        /* å¤–éƒ¨ä¸­æ–­ç½®é«˜ç”µå¹³  */
  55   1        SendCmdPin  = 1;        /* ä½¿SendCmdPinå¯è¯» */
  56   1      
  57   1        while(1){
  58   2          for(u8temp = 0; u8temp < 120; u8temp++)
  59   2            delay(13333);
  60   2          SendInfraredSignal(cmdOpen26);
  61   2          for(u8temp = 0; u8temp < 120; u8temp++)
  62   2            delay(13333);
  63   2          for(u8temp = 0; u8temp < 120; u8temp++)
  64   2            delay(13333);
  65   2          for(u8temp = 0; u8temp < 120; u8temp++)
  66   2            delay(13333);
  67   2          SendInfraredSignal(cmdClose26);
  68   2          for(u8temp = 0; u8temp < 120; u8temp++)
  69   2            delay(13333);
  70   2          for(u8temp = 0; u8temp < 120; u8temp++)
  71   2            delay(13333);
  72   2        }
  73   1      }
  74          
  75          /* PWM0åˆå§‹åŒ–ï¼Œä¸»é¢‘19.456Mï¼Œåˆ†é¢‘ä¸º38KHz */
  76          void PWM0Init(void){
  77   1        ACC   = P_SW1;
  78   1        ACC   &=  ~(CCP_S0|CCP_S1);   //CCP_S0=0, CCP_S1=0
  79   1        P_SW1 = ACC;          //P1.1:CCP0 , P1.0:CCP1 , P3.7:CCP2
  80   1      
  81   1        CCON = 0;   //åˆå§‹åŒ–PCAæ§åˆ¶å¯„å­˜å™¨
  82   1        CL   = 0;   //å¤ä½PCA
  83   1        CH   = 0;
  84   1        CMOD = 0x0A;  //è®¾ç½®PCAæ—¶é’Ÿæºï¼Œsysclk/4
  85   1      
  86   1        PCA_PWM0  = 0x40;   //7ä½ï¼Œé¢‘ç‡ = 19456000/4/128 = 38000
  87   1        CCAP0H = CCAP0L = 0x59;   //å ç©ºæ¯” = (0x7F - 0x59) / 0x7F = (127 - 89)/127 = 29.9%
  88   1        CCAPM0 = 0x42;
  89   1      
  90   1        CR = 1;           //PCAå®šæ—¶å™¨å¼€å§‹å·¥ä½œ
  91   1      }
  92          
  93          /* ä¸²å£ä¼ è¾“ï¼ˆä¸²å£1ï¼‰åˆå§‹åŒ– */
  94          void Uart1Init(void)    //9600bps@19.456MHz
  95          {
  96   1        SCON = 0x50;    //8ä½æ•°æ®,å¯å˜æ³¢ç‰¹ç‡
  97   1        AUXR |= 0x40;   //å®šæ—¶å™¨1æ—¶é’Ÿä¸ºFosc,å³1T
  98   1        AUXR &= 0xFE;   //ä¸²å£1é€‰æ‹©å®šæ—¶å™¨1ä¸ºæ³¢ç‰¹ç‡å‘ç”Ÿå™¨
  99   1        TMOD &= 0x0F;   //è®¾å®šå®šæ—¶å™¨1ä¸º16ä½è‡ªåŠ¨é‡è£…æ–¹å¼
 100   1        TL1  = 0x05;    //è®¾å®šå®šæ—¶åˆå€¼
 101   1        TH1  = 0xFE;    //è®¾å®šå®šæ—¶åˆå€¼
 102   1        ET1  = 0;     //ç¦æ­¢å®šæ—¶å™¨1ä¸­æ–­
 103   1        TR1  = 1;     //å¯åŠ¨å®šæ—¶å™¨1
 104   1        ES   = 1;     //æ‰“å¼€ä¸²å£ä¸­æ–­
 105   1        IP   = 0x10;    //ä¸­æ–­ä¼˜å…ˆçº§è®¾ç½®ï¼Œä¸²å£ä¸­æ–­ä¼˜å…ˆï¼Œå¯åµŒå¥—è¿›å…¥å¤–éƒ¨ä¸­æ–­
 106   1      }
 107          
 108          /* è®¡æ—¶å™¨0åˆå§‹åŒ– */
 109          void T0Init(void){
 110   1        TMOD &= 0xF0;
 111   1        TMOD |= 0x01;       /* å°†TMOD é«˜4ä½ä¸å˜ï¼Œä½4ä½ç½®0001ï¼Œä½¿ç”¨å®šæ—¶å™¨T0 */
 112   1      
 113   1        TR0 = 0;          /* TR:è®¡æ—¶ä½¿èƒ½ï¼Œç½®1è®¡æ—¶ï¼Œç½®0åœæ­¢ */
 114   1        ET0 = 0;          /* ET:å®šæ—¶å™¨ä¸­æ–­ä½¿èƒ½ï¼Œç½®1ä½¿èƒ½ï¼Œç½®0å¤±èƒ½ */
C51 COMPILER V9.56.0.0   MAIN                                                              07/20/2017 22:10:19 PAGE 3   

 115   1      }
 116          
 117          /* å¤–éƒ¨ä¸­æ–­IT0åˆå§‹åŒ– */
 118          void IT0Init(){
 119   1        P32 = 1;
 120   1        IT0 = 1;            /* IT:å¤–éƒ¨ä¸­æ–­æ–¹å¼é€‰æ‹©ï¼Œ0:ä¸Šå‡æ²¿ä¸‹é™æ²¿éƒ½è§¦å‘ï¼Œ1:ä¸‹é™æ²¿è§¦å‘ */
 121   1        EX0 = 1;            /* EX:å¤–éƒ¨ä¸­æ–­ä½¿èƒ½ï¼Œ1:ä½¿èƒ½ï¼Œ0:å¤±èƒ½ */
 122   1      }
 123          
 124          /**
 125           * å¾®ç§’çº§åˆ«å»¶æ—¶
 126           *      67.5us = 100
 127           * 9ms    = 9000us = 13333
 128           * 4.5ms  = 4500us = 6667
 129           *      560us  = 830
 130           *        1690us = 2504
 131           */
 132          void delay(u16 us){
 133   1        while(us)us--;
 134   1      }
 135          
 136          /**
 137           * çº¢å¤–å‘å°„ä¸€ä¸ªå­—èŠ‚ï¼Œä»é«˜ä½å‘ä½ä½å‘å°„
 138           * 0ï¼š 560usé«˜ç”µå¹³ï¼Œ560usä½ç”µå¹³
 139           * 1ï¼š 560usé«˜ç”µå¹³ï¼Œ1690usä½ç”µå¹³
 140           */
 141          void sendInfraredByte(uchar dat){
 142   1        uchar pos2;
 143   1      
 144   1        for(pos2 = 0; pos2 < 8; pos2++){
 145   2          if((dat & (0x80 >> pos2)) == 0x00){
 146   3            /* å‘å°„0 */
 147   3            SendDataPin = 1;
 148   3            delay(830);
 149   3            SendDataPin = 0;
 150   3            delay(830);
 151   3            SendDataPin = 1;
 152   3          }else{
 153   3            /* å‘å°„1 */
 154   3            SendDataPin = 1;
 155   3            delay(830);
 156   3            SendDataPin = 0;
 157   3            delay(2504);
 158   3            SendDataPin = 1;
 159   3          }
 160   2        }
 161   1      }
 162          
 163          /* å‘å°„çº¢å¤–ä¿¡å· */
 164          void SendInfraredSignal(u8* sendCmd){
 165   1        EA = 0;   /* å‘é€çº¢å¤–ä¿¡å·æ—¶ç¦æ­¢ä¸­æ–­ */
 166   1      
 167   1        /* 9msé«˜ç”µå¹³ */
 168   1        SendDataPin = 1;
 169   1        delay(13333);
 170   1      
 171   1        /* 4.5msä½ç”µå¹³ */
 172   1        SendDataPin = 0;
 173   1        delay(6667);
 174   1      
 175   1        /**
 176   1         * æŒ‰ç…§æ•°ç»„ä¸­çš„æ•°æ®ä¾æ¬¡å‘å¤–å‘å°„
C51 COMPILER V9.56.0.0   MAIN                                                              07/20/2017 22:10:19 PAGE 4   

 177   1         */
 178   1        for(i = 0; i < 13; i++){
 179   2          sendInfraredByte(sendCmd[i]);
 180   2        }
 181   1      
 182   1        SendDataPin = 1;
 183   1        delay(830);
 184   1        SendDataPin = 0;
 185   1      
 186   1        EA = 1;   /* æ‰“å¼€ä¸­æ–­ */
 187   1      }
 188          
 189          u16 GetLowTime(){
 190   1        TH0 = 0;
 191   1        TL0 = 0;        /* è®¡æ•°å™¨0çš„é«˜ä½8ä½ï¼Œåˆå§‹è®¾ä¸º0 */
 192   1      
 193   1        TR0 = 1;        /* è®¡æ•°å™¨0è®¡æ—¶ä½¿èƒ½ */
 194   1        while(!IR_INPUT){
 195   2          if(TH0 > 0x50)    /* å¦‚æœé«˜8ä½å¤§äºæŸä¸€é˜ˆå€¼ï¼Œè¡¨ç¤ºå¼‚å¸¸ */
 196   2            break;
 197   2        }
 198   1        TR0 = 0;        /* è®¡æ•°å™¨å¤±èƒ½ */
 199   1        return TH0 * 256 + TL0; /* é«˜4ä½*256 + ä½4ä½ = è®¡æ—¶å¼€å§‹åè·‘è¿‡çš„æ—¶é—´ */
 200   1      }
 201          
 202          u16 GetHighTime(){
 203   1        TH0 = 0;
 204   1        TL0 = 0;        /* è®¡æ•°å™¨çš„é«˜ä½8ä½ï¼Œåˆå§‹è®¾ä¸º0 */
 205   1      
 206   1        TR0 = 1;        /* è®¡æ•°å™¨è®¡æ—¶ä½¿èƒ½ */
 207   1        while(IR_INPUT){
 208   2          if(TH0 > 0x50)    /* å¦‚æœé«˜8ä½å¤§äºæŸä¸€é˜ˆå€¼ï¼Œè¡¨ç¤ºå¼‚å¸¸ */
 209   2            break;
 210   2        }
 211   1        TR0 = 0;        /* è®¡æ•°å™¨å¤±èƒ½ */
 212   1        return TH0 * 256 + TL0; /* é«˜4ä½*256 + ä½4ä½ = è®¡æ—¶å¼€å§‹åè·‘è¿‡çš„æ—¶é—´ */
 213   1      }
 214          
 215          /**
 216           * INT0ä¸­æ–­å…¥å£
 217           * interruptå…³é”®å­—ç”¨æ³•
 218           * interrupt 0 : å¤–éƒ¨ä¸­æ–­0 P3.2
 219           * interrupt 1 : å®šæ—¶å™¨ä¸­æ–­0
 220           * interrupt 2 : å¤–éƒ¨ä¸­æ–­1 P3.3
 221           * interrupt 3 : å®šæ—¶å™¨ä¸­æ–­1
 222           * interrupt 4 : ä¸²å£ä¸­æ–­
 223           */
 224          void INT0_Routine() interrupt 0{
 225   1        u16temp = GetLowTime();
 226   1      
 227   1        if(u16temp < 9333 || u16temp > 17333){        /* åˆ¤æ–­æ˜¯å¦åœ¨9msä»¥å†… */
 228   2          bufferLength = 0;
 229   2          IE0 = 0;                    /* è½¯ä»¶é‡Šæ”¾IE0, å…è®¸å¤–éƒ¨ä¸­æ–­0å†æ¬¡è¿›å…¥ */
 230   2          return;
 231   2        }
 232   1      
 233   1        u16temp = GetHighTime();
 234   1        if(u16temp < 4666 || u16temp > 8666){       /* åˆ¤æ–­æ˜¯å¦åœ¨4.5msä»¥å†… */
 235   2          bufferLength = 0;
 236   2          IE0 = 0;
 237   2          return; 
 238   2        }
C51 COMPILER V9.56.0.0   MAIN                                                              07/20/2017 22:10:19 PAGE 5   

 239   1      
 240   1        while(1){
 241   2          for(j = 0; j < 8; j++){
 242   3            u16temp = GetLowTime();
 243   3            if(u16temp < 581 || u16temp > 1079){        /* åˆ¤æ–­æ˜¯å¦æ˜¯560us */
 244   4              bufferLength = 0;
 245   4              IE0 = 0;
 246   4              return;
 247   4            }
 248   3            u16temp = GetHighTime();
 249   3            if(u16temp > 581 && u16temp < 1079){        /* æ¥æ”¶åˆ°äº†0 */
 250   4              buffer[bufferLength] = buffer[bufferLength] << 1;
 251   4            }else if(u16temp > 1752 && u16temp < 3255){     /* æ¥æ”¶åˆ°äº†1 */
 252   4              buffer[bufferLength] = buffer[bufferLength] << 1;
 253   4              buffer[bufferLength] |= 0x01;
 254   4            }else if(u16temp >= 3255){              /* >=3255æ—¶è¡¨ç¤ºç»“æŸä½ï¼Œæ— ä¿¡å·äº† */
 255   4              IE0 = 0;
 256   4              u16temp = 5000;               /* å»¶æ—¶ */
 257   4              while(u16temp--);
 258   4      
 259   4              for(i = 0; i < bufferLength; i++){
 260   5                sending = 1;
 261   5                SBUF = buffer[i];         
 262   5                while(sending);   /* å‘é€æ¯ä¸ªå­—èŠ‚åéƒ½ç­‰UARTä¸­æ–­ä¸­å°†sendingå¤ä½ï¼Œé˜²æ­¢é”™ä¹± */
 263   5              }     
 264   4      
 265   4              bufferLength = 0;
 266   4              return;
 267   4            }else{                        /* <=581,æ•°æ®å¼‚å¸¸ï¼Œé‡ç½®è¿”å› */
 268   4              IE0 = 0;
 269   4              bufferLength = 0;
 270   4              return;
 271   4            }
 272   3          }
 273   2      
 274   2          bufferLength++;
 275   2        }
 276   1      }
 277          
 278          void UART_Routine() interrupt 4{
 279   1        if(TI){       //æœ¬æ¬¡ä¸­æ–­æ˜¯å‘é€ä¸­æ–­
 280   2          TI = 0;     //å‘é€å®Œäº†æ¸…é›¶
 281   2          REN = 1;    //å‘é€å®Œäº†å†æ¥å—
 282   2          sending = 0;  //æ¸…ç©ºå‘å°„æ ‡å¿—
 283   2        }
 284   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    744    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     33       3
   IDATA SIZE       =    128    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
